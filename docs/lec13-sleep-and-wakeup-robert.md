# Sleep&Wakeup
## 线程切换过程中锁的限制
+ 在XV6中，任何时候调用swtch函数都会从一个线程切换到另一个线程，通常是在用户进程的内核线程和调度器线程之间切换
+ 在调用switch函数之前，总是会先获取线程对应的用户进程的锁
  + 所以过程是这样，一个进程先获取自己的锁，然后调用swtch函数切换到调度器线程，调度器线程再释放进程锁
+ 实际上的代码顺序更像这样：
  + 一个进程出于某种原因想要进入休眠状态
    + 比如说出让CPU或者等待数据，它会先获取自己的锁；
  + 之后进程将自己的状态从RUNNING设置为RUNNABLE
  + 之后进程调用switch函数，其实是调用sched函数在sched函数中再调用的switch函数
  + switch函数将当前的线程切换到调度器线程
  + 调度器线程之前也调用了switch函数，现在恢复执行会从自己的switch函数返回
  + 返回之后，调度器线程会释放刚刚出让了CPU的进程的锁
+ 在第1步中获取进程的锁的原因是
  + 这样可以阻止其他CPU核的调度器线程在当前进程完成切换前，发现进程是RUNNABLE的状态并尝试运行它
+ 为什么要阻止呢？
  + 因为其他每一个CPU核都有一个调度器线程在遍历进程表单
  + 如果没有在进程切换的最开始就获取进程的锁的话，其他CPU核就有可能在当前进程还在运行时
  + 认为该进程是RUNNABLE并运行它
  + 而两个CPU核使用同一个栈运行同一个线程会使得系统立即崩溃
+ 所以，在进程切换的最开始，进程先获取自己的锁
  + 并且直到调用switch函数时也不释放锁
  + 而另一个线程，也就是调度器线程会在进程的线程完全停止使用自己的栈之后，再释放进程的锁
  + 释放锁之后，就可以由其他的CPU核再来运行进程的线程，因为这些线程现在已经不在运行了
+ XV6中，不允许进程在执行swtch函数的过程中，持有任何其他的锁
  + 所以，进程在调用switch函数的过程中，必须要持有p->lock（注，也就是进程对应的proc结构体中的锁）
  + 但是同时又不能持有任何其他的锁
  + 这也是包含了Sleep在内的很多设计的限制条件之一
  + 如果你是一个XV6的程序员，你需要遵循这条规则
  + 接下来解释一下背后的原因，首先构建一个不满足这个限制条件的场景：
    + 我们有进程P1，P1的内核线程持有了p->lock以外的其他锁
      + 这些锁可能是在使用磁盘，UART，console过程中持有的
    + 之后内核线程在持有锁的时候，通过调用swtch/yield/sched函数出让CPU，这会导致进程P1持有了锁，但是进程P1又不在运行
    + 假设我们在一个只有一个CPU核的机器上，进程P1调用了switch函数将CPU控制转给了调度器线程
    + 调度器线程发现还有一个进程P2的内核线程正在等待被运行，所以调度器线程会切换到运行进程P2
    + 假设P2也想使用磁盘，UART或者console，它会对P1持有的锁调用acquire
      + 这是对于同一个锁的第二个acquire调用
    + 当然这个锁现在已经被P1持有了，所以这里的acquire并不能获取锁
    + 假设这里是spinlock，那么进程P2会在一个循环里不停的“旋转”并等待锁被释放
    + 但是很明显进程P2的acquire不会返回，所以即使进程P2稍后愿意出让CPU，P2也没机会这么做
    + 之所以没机会是因为P2对于锁的acquire调用在直到锁释放之前都不会返回
      + 而唯一锁能被释放的方式就是进程P1恢复执行并在稍后release锁
      + 但是这一步又还没有发生，因为进程P1通过调用switch函数切换到了P2，而P2又在不停的“旋转”并等待锁被释放
    + 这是一种死锁，它会导致系统停止运行
+ **在XV6中禁止在调用switch时持有除进程自身锁（注，也就是p->lock）以外的其他锁**
















































































































































































