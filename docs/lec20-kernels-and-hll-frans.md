# kernels-and-hll-frans
## C语言实现操作系统的优劣势
+ 为什么大多数操作系统都是用C实现：
  + 首先C提供了大量的控制能力，C可以完全控制内存分配和释放
  + C语言几乎没有隐藏的代码，你几乎可以在阅读C代码的时候想象到对应的RISC-V机器指令是什么
  + 通过C可以有直接内存访问能力，你可以读写PTE的bit位或者是设备的寄存器
  + 使用C会有极少的依赖，因为你不需要一个大的程序运行时
    + 你几乎可以直接在硬件上运行C程序
    + 只通过几行汇编代码，你就可以运行C代码
--------------------------------------
+ 在过去几十年已经证明了，很难写出安全的C代码。这里存在各种各样的Bug
  + 首先是最著名的buffer overrun
    + 比如说数组越界，撑爆了Stack等等
  + 其次是use-after-free bugs
    + 你可能会释放一些仍然在使用的内存，之后其他人又修改了这部分内存
  + 第三，当线程共享内存时，很难决定内存是否可以被释放
## 是否应该将 HLL 用于新内核？
所以应该在内核中使用高级编程语言？——也就是说，是否应该使用GC
+ 如果性能真的至关重要
  + 比如说不能牺牲15%的性能，那么你应该使用C
+ 如果你想最小化内存使用，你也应该使用C
+ 如果安全更加重要，那么应该选择高级编程语言
+ 或许在很多场景下，性能不是那么重要，那么使用高级编程语言实现内核是非常合理的选择
高级编程语言还有一些其他的优点：
+ 首先是Type safety，类型安全
+ 通过GC实现了自动的内存管理，所以free更容易了
  + GC会为你完成所有的内存释放工作
+ 对并发更友好
+ 有更好的抽象，接口和类等面向对象的语法使得你可以写出更加模块化的代码
-----------------------------------
高级编程语言通常都有一些额外的代价，这被称为High Level Language Tax
+ 比如说在索引一个数组元素时检查数据边界
  + 比如说检查空指针
  + 比如说类型转换
+ 除此之外，GC需要花费一些时间来跟踪哪些对象可以被释放
除了性能之外，高级编程语言与内核编程本身不兼容
+ 比如说高级编程语言没有直接访问内存的能力
  + 因为这从原则上违反了Type safety
+ 高级编程语言不能集成汇编语言，而在内核中的一些场景总是需要一些汇编程序
  + 比如说两个线程的context switching
  + 或者系统启动
+ 编程语言本身支持的并发与内核需要的并发并不一致
  + 比如我们在调度线程的时候，一个线程会将锁传递给另一个线程
  + 一些并发管理模式在用户程序中不太常见，但是在内核中会出现
## 高级编程语言选择 --- Go
基于以下原因，我们选用了Golang：
+ 这是一个静态编译的编程语言，和Python不同，这里没有解释器
  + 我们喜欢静态编译的语言的原因是编译语言性能通常更好，实际上Go编译器就非常好，所以基本上来说这是一种高性能编程语言
+ 另外，Golang被设计成适合系统编程，而内核就是一种系统编程所以Golang也符合这里的场景。例如：
  + Golang非常容易调用汇编代码，或者其他的外部代码
  + Golang能很好地支持并发
  + Golang非常的灵活
+ 另一个原因是Golang带有Garbage Collector
  + 使用高级编程语言的一个优点就是你不需要管理内存，而GC是内存管理的核心

（可惜当时老师写论文写的早，没有用Rust语言，不然，我可太心动了）
## Biscuit
Biscuit的特性：
+ 首先它支持多核CPU
  + Golang对于并发有很好的支持，所以Biscuit也支持多核CPU
  + 类似的，XV6却只对多核CPU有有限的支持
  + 所以在这里，我们相比XV6有更好的同步协调机制
+ 它支持用户空间多线程，而XV6并没有
+ 它有一个相比XV6更高性能的Journaled File System 
  + （注，Journaled就是指log，可以实现Crash Recovery）
  + 它与EXT3的Journaled File System有点类似
+ 它有在合理范围内较为复杂的虚拟内存系统，使用了VMAs并且可以支持mmap和各种功能
+ 它有一个完整的TCP/IP栈，可以与其他的服务器通过互联网连接在一起
+ 它还有两个高性能的驱动，一个是Intel的10Gb网卡，以及一个非常复杂的磁盘驱动AHCI，这比virtIO磁盘驱动要复杂的多
Biscuit支持的用户程序中：
+ 每个用户程序都有属于自己的Page Table
+ 用户空间和内核空间的内存是由硬件隔离的，也就是通过PTE的User/Kernel bit来区分
+ 每个用户线程都有一个对应的内核线程
  + 这样当用户线程执行系统调用时，程序会在对应的内核线程上运行
  + 如果系统调用阻塞了，那么同一个用户地址空间的另一个线程会被内核调度起来
+ 如之前提到的，内核线程是由Go runtime提供的goroutine实现的
  + 如果你曾经用Golang写过用户空间程序，其中你使用go关键字创建了一个goroutine
  + 这个goroutine就是Biscuit内核用来实现内核线程的goroutine
-------------------------------------
来看一下系统调用。就像刚刚的问题一样，这里的系统调用工作方式与XV6基本一致：
+ 用户线程将参数保存在寄存器中，通过一些小的库函数来使用系统调用接口
+ 之后用户线程执行SYSENTER
  + 现在Biscuit运行在x86而不是RISC处理器上，所以进入到系统内核的指令与RISC-V上略有不同
+ 但是基本与RISC-V类似，控制权现在传给了内核线程
+ 最后内核线程执行系统调用，并通过SYSEXIT返回到用户空间
--------------------------------------
在实现Biscuit的时候有一些挑战：
+ 首先，我们需要让Go runtime运行在裸机之上
  + 我们希望对于runtime不做任何修改或者尽可能少的修改
    + 这样当Go发布了新的runtime，我们就可以直接使用
  + 在开发Biscuit这几年，我们升级了Go runtime好几次，所以Go runtime直接运行在裸机之上是件好事
    + 并且实际上也没有非常困难
    + Golang的设计都非常小心的不去依赖操作系统，因为Golang想要运行在多个操作系统之上
    + 所以它并没有依赖太多的操作系统特性，我们只需要仿真所需要的特性
      + 大部分这里的特性是为了让Go runtime能够运行起来，一旦启动之后，就不太需要这些特性了
+ 我们需要安排goroutine去运行不同的应用程序
  + 通常在Go程序中，只有一个应用程序
  + 而这里我们要用goroutine去运行不同的用户应用程序，这些不同的用户应用程序需要使用不同的Page Table
  + 这里困难的点在于，Biscuit并不控制调度器
    + 因为我们使用的是未经修改过的Go runtime，我们使用的是Go runtime调度器
    + 所以在调度器中我们没法切换Page Table
  + Biscuit采用与XV6类似的方式，它会在内核空间和用户空间之间切换时更新Page Table
    + 所以当进入和退出内核时，我们会切换Page Table
    + 这意味着像XV6一样，当你需要在用户空间和内核空间之间拷贝数据时
      + 你需要使用copy-in和copy-out函数，这个函数在XV6中也有
      + 它们基本上就是通过软件完成Page Table的翻译工作
+ 另一个挑战就是设备驱动，Golang通常运行在用户空间，所以它并不能从硬件收到中断
  + 但是现在我们在裸机上使用它，所以它现在会收到中断
    + 比如说定时器中断，网卡中断，磁盘驱动中断等等
  + 我们需要处理这些中断
    + 然而在Golang里面并没有一个概念说是在持有锁的时候关闭中断
    + 因为中断并不会出现在应用程序中，所以我们在实现设备驱动的时候要稍微小心
  + 我们采取的措施是在设备驱动中不做任何事情
    + 我们不会考虑锁
    + 我们不会分配任何内存
  + 我们唯一做的事情是向一个非中断程序发送一个标志，之后唤醒一个goroutine来处理中断
    + 在那个goroutine中，你可以使用各种各样想要的Golang特性
    + 因为它并没有运行在中断的context中，它只是运行在一个普通goroutine的context中
----------------------------
## Heap exhaustion
Heap耗尽问题
<img src=".\picture\image179.png">

+ 假设蓝色的矩形是内核，内核会有一个heap，它会从其中申请动态内存
+ 在XV6中，我们并没有这样一个heap，我们在内核中没有内存分配器，所有内存都是静态分配的
+ 但是任何其他的内核中，都会有heap
  + 所以你在内核中可以调用malloc和free
  + 可能通过heap分配的对象有socket对象，文件描述符对象和进程对象
+ 所以，我们在XV6中静态分配的所有结构体
  + 例如struct proc，struct fd，在正常的内核中都是动态分配的
  + 所以当你打开一个新的文件描述符时，内核会通过heap分配一个文件描述符对象
+ 这里的问题是，你可以运行很多个应用程序
  + 它们会打开很多个文件描述符，拥有很多个socket，它们会逐渐填满heap
<img src=".\picture\image180.png">

+ 在某个时间点，heap会被填满，这时没有额外的空间可以用来分配一个新的对象
  + 如果这时应用程序需要打开一个新的文件描述符
  + 或者调用了fork使得内核想要在heap中分配一个新的proc结构体，heap中没有了空间
+ 在很多内核中，你可以对malloc返回错误
  + 实际上，XV6就是这么做的
  + 但是在Go runtime中，当你调用new来分配一个Go对象
    + 并没有error condition，new总是可以成功
-------------------------------
解决方法：
+ 第一种方法我们在XV6中见过
  + 如果XV6不能找到一个空闲的block cache来保存disk block，它会直接panic
  + 这并不是一个实际的解决方案，所以我们称之为strawman
+ 另一个strawman方法是
  + 当你在申请一块新的内存时，你会调用alloc或者new来分配内存，你实际上可以在内存分配器中进行等待
  + 这实际上也不是一个好的方案，原因是你可能会有死锁
    + 假设内核有把大锁，当你调用malloc
    + 因为没有空闲内存你会在内存分配器中等待，那么这时其他进程都不能运行了
    + 因为当下一个进程想要释放一些内存时，但是因为死锁也不能释放
      + 对于内核中有大锁的情况，这里明显有问题
      + 但是即使你的锁很小，也很容易陷入到这种情况：
        + 在内存分配器中等待的进程持有了其他进程需要释放内存的锁，这就会导致死锁的问题
+ 下一个strawman方法是，如果没有内存了就返回空指针，你检查如果是空指针就直接失败，这被称为bail out
  + 但是bail out并不是那么直观，进程或许已经申请了一些内存
  + 那么你需要删除它们，你或许做了一部分磁盘操作
  + 比如说你在一个多步的文件系统操作中间，你只做了其中的一部分，你需要回退
+ Linux使用了前面两种方法，但是两种方法都有问题
+ 对于Biscuit来说，strawman 2解决方案不可能实施
  + 因为new不会fail，它总是能成功
  + 除此之外，这里的方案都不理想，所以我们需要有一种更好的方法
## Heap exhaustion solution
+ Biscuit的解决方案非常直观
  + 当应用程序执行系统调用
    + 例如read，fork时
  + 在系统调用的最开始，跳转到内核之前，它会先调用reserve函数
    + reserve函数会保留足够的内存以运行系统调用
    + 所以reserve会保留足够这个系统调用使用的空闲内存，以使得系统调用总是能成功
  + 所以一旦系统调用被执行，且保留了足够的内存，那么它就可以一直运行而不会有内存耗尽和heap exhaustion的问题
+ 如果reserve函数执行时没有足够的内存，那么程序会在这里等待
  + 因为现在在系统调用的最开始，系统调用现在还没有持有任何的锁，也没有持有任何的资源
    + 所以在这里等待完全没有问题，也不会有死锁的风险
  + 当程序在等待的时候，内核可以撤回cache并尝试在heap增加空闲空间
    + 比如说kill一个进程来迫使释放一些内存
    + 一旦内存够用了，并且内核决定说是可以满足需要保留的内存，之后内核会让系统调用继续运行，然后执行系统调用需要的操作
+ 在最后，当系统调用完成的时候
  + 所有之前保留的内存都返回到池子中
  + 这样后续的系统调用可以继续使用
+ 这个方案中有一些很好的特性：
  + 在内核中没有检查
    + 你不需要检查内存分配是否会失败，在我们的例子中这尤其得好
    + 因为在Golang中内存分配不可能会失败
  + 这里没有error handling代码
  + 这里没有死锁的可能，因为你在最开始还没有持有锁的时候，就避免了程序继续执行
## Evaluation: HLL benefits
+ 有关高级编程语言，我们要回答三个问题：
  + 首先，我们有没有作弊？或许我们避免使用了所有Golang提供的高级编程语言中代价较高的功能
  + 其次，高级编程语言是否有简化Biscuit代码
  + 最后，高级编程语言是否能阻止前面提到的内核漏洞
下面依次展开：
### 避免使用了所有Golang提供的高级编程语言中代价较高的功能
<img src=".\picture\image181.png">

+ 如图是一些高级语言特性在每1000行代码中的使用量。图中X轴是语言特性：
  + allocation对应于new
  + maps就是hashtable
  + slice是动态数组
  + channel是同步的工具，如你所见我们用的很少，Go runtine和Moby也用的很少
  + 很明显我们最喜欢的特性就是函数返回多个值
  + 我们使用了Closure（闭包）
  + 我们稍微使用了defer
  + 我们使用了Interface
  + 使用了Type assertion来以一种类型安全的方式将一个类型转换成另一个类型
  + 同时我们也import了很多包，Biscuit内核是由很多个包构建出来的，而不是一个大的单一的程序
+ 所以从这张图中可以得出的主要结论是：Biscuit使用了Golang提供的高级编程语言特性，而不是为了得到好的性能而避开使用它们
### 高级编程语言有没有简化Biscuit代码
+ 使用Garbage allocation是极好的
  + 在XV6，当调用exit时，有大量的结构化数据需要被释放回给内核，这样后面的进程才能使用
  + 如果使用Garbage Collector这里的工作着实容易
    + Garbage Collector会完成这里的所有工作，你基本不用做任何事情
  + 如果你从地址空间申请了一段内存，对应这段内存的VMA会自动被GC释放，所以这里可以简化代码
+ 如之前所说的，函数返回多个值对于代码风格很好
  + 闭包很好，map也很好
  + XV6中很多地方通过线性扫描查找数据，但是如果你有map和hashtable作为可以直接使用的对象，那么你就不用线性扫描了
    + 你可以直接使用map，runtime会高效地为你实现相应的功能
    + 所以直观上的感受是，你可以得到更简单的代码
+ 这里有个最简单的例子
  + 假设你申请了一些动态的对象，比如说buffer，你fork一个线程来处理这个buffer，原线程也会处理同一个buffer
  + 当两个线程都完成了工作，buffer需要被释放，这样内存才可以被后面的内核代码使用
  + 这在C语言里面有点难协调，因为你需要有某种方式来决定buffer不再被使用
    + 如果你使用GC，那么就没什么好决定的，因为当两个线程都处理完buffer之后，没有线程会指向那个buffer
    + GC会从线程栈开始追踪，并且在任何线程栈中都找不到buffer
    + 因此GC会在稍后某个时间释放内存
    + 所以在一个带GC的编程语言中，你完全不必考虑这个问题
+ 在C中你可以这样解决这个问题，为对象增加引用计数
  + 引用计数需要被锁或者一些原子性操作保护，当引用计数到达0时，你可以释放内存

### 高级编程语言是否能阻止前面提到的内核漏洞
手动的检查了所有的CVEs Bug，并尝试确定Golang是否修复了问题
<img src=".\picture\image182.png">

+ 第一行代表我们不能弄清楚这些Bug的结果是什么，它会怎么展现
  + 我们知道如何修复这些问题，但是我们不能确定Golang是否能避免这些问题
+ 有很多逻辑Bug，可以认为Golang会有与C相同的Bug，所以结果是相同的
+ 接下来是40个memory-safety Bugs
  + 包括了use-after-free，double-free，out-of-bound
  + 其中8个直接消失了，因为GC考虑了内存释放，32个会产生panic，比如说数组越界
  + 当然panic并不好，因为内核会崩溃，但是或许要比直接的安全漏洞更好
  + 所以在这40个Bug中，高级编程语言有帮到我们











