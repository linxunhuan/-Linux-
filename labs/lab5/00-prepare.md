# xv6 惰性页面分配
## 官方介绍
+ 操作系统可以对页表硬件施展的众多巧妙技巧之一是
  + 延迟分配用户空间堆内存
+ xv6 应用程序使用 sbrk() 系统调用向内核请求堆内存
  + 在我们提供的内核中,sbrk() 分配物理内存并将其映射到进程的虚拟地址空间
  + 内核可能需要很长时间才能为大型请求分配和映射内存
    + 例如，考虑 1 GB 由 262,144 个 4096 字节页面组成
    + 即使每个页面单独都很少，这也是一个巨大的分配数量
  + 此外，某些程序分配的内存比它们实际使用的内存多（例如，实现稀疏数组）
+ 为了让 sbrk() 在这些情况下更快地完成，复杂的内核会延迟分配用户内存
  + 也就是说,sbrk() 不会分配物理内存
  + 只是记住已分配哪些用户地址，并在用户页表中将这些地址标记为无效
+ 当进程首次尝试使用任何给定的延迟分配内存页面时
  + CPU 会产生页面错误
  + 内核会通过分配物理内存、将其清零并进行映射来处理该错误
  + 您将在本实验中将此延迟分配功能添加到 xv6
+ 在开始编码之前，请阅读 xv6 书的第 4 章(特别是 4.6)以及可能会修改的相关文件
  + kernel/trap.c
  + kernel/vm.c
  + kernel/sysproc.c

## xv6 第 4 章 4.6
（第四章全部内容在上一个实验已经全部展示，这里重点展示题目里说到的4.6）
### 锁的顺序
+ 假设某段代码的两条执行路径都需要锁 A 和 B
  + 但路径1获得锁的顺序是 A、B
  + 路径2获得锁的顺序是 B、A
    + 这样就有能路径1获得了锁 A，而在它继续获得锁 B 之前，路径2获得了锁 B，这样就死锁了
+ 这时两个路径都无法继续执行下去了
  + 因为这时路径1需要锁 B，但锁 B已经在路径2手中了
  + 反之路径2也得不到锁 A
+ 为了避免这种死锁，所有的代码路径获得锁的顺序必须相同
+ 避免死锁也是我们把锁作为函数使用规范的一部分的原因：
  + **调用者必须以固定顺序调用函数，这样函数才能以相同顺序获得锁**
-------------------
+ 由于 xv6 本身比较简单，它使用的锁也很简单，所以 xv6 几乎没有锁的使用链，最长的锁链也就只有两个锁
  + 例如，ideintr 在调用 wakeup 时持有 ide 锁，而 wakeup 又需要获得 ptable.lock
  + 还有很多使用 sleep/wakeup 的例子，它们要考虑锁的顺序是因为 sleep 和 wakeup 中有比较复杂的不变量，我们会在第5章讨论。
  + 文件系统中有很多两个锁的例子
    + 例如文件系统在删除一个文件时必须持有该文件及其所在文件夹的锁
    + xv6 总是首先获得文件夹的锁，然后再获得文件的锁
