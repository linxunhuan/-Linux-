# RISC-V assembly
## 题目介绍
+ 了解一些 RISC-V 汇编代码非常重要，您在 6.004 中接触过这些代码
+ 您的 xv6 存储库中有一个文件 user/call.c
+ make fs.img 会对其进行编译，并在 user/call.asm 中生成该程序的可读汇编版本
+ 阅读 call.asm 中函数 g、f 和 main 的代码
+ RISC-V 的使用手册位于参考页面上。以下是一些您应该回答的问题（将答案存储在文件 answers-traps.txt 中）：
  + 哪些寄存器包含函数的参数？例如，在 main 调用 printf 时，哪个寄存器保存 13？
  + 在 main 的汇编代码中，对函数 f 的调用在哪里？对 g 的调用在哪里？（提示：编译器可能会内联函数）
  + 函数 printf 位于什么地址？
  + 在 main 函数中，jalr 到 printf 之后，寄存器 ra 中的值是什么？
  + 运行下面的代码
```c
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);    
```
输出是什么？
如果 RISC-V 是大端序的，要实现同样的效果，需要将 i 设置为什么？需要将 57616 修改为别的值吗？
  +  在下面的代码中，'y=' 之后会答应什么？ (note: 答案不是一个具体的值) 为什么?
```c
printf("x=%d y=%d", 3);
```
## 做题步骤
### 阅读 call.asm 中函数 g、f 和 main 的代码
+ 终端输入make fs.img
+ 在call.asm 中找到函数 g、f 和 main 的代码
下面展示出来
```s
0000000000000000 <g>:
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int g(int x) {
   0:	1141       addi	sp,sp,-16   //减少栈指针 sp 的值 16 字节，为局部变量腾出空间
   2:	e422       sd	s0,8(sp)    //将寄存器 s0 的值存储到栈指针 sp 的偏移 8 位置
   4:	0800       addi	s0,sp,16    // 将栈指针 sp 的值加 16，并存储到寄存器 s0 中
  return x+3;
}
   6:	250d       addiw a0,a0,3    // 将 a0 寄存器的值加 3，结果存储到 a0 寄存器中
   8:	6422       ld	s0,8(sp)    // 从栈指针 sp 的偏移 8 位置加载值到寄存器 s0 中
   a:	0141       addi	sp,sp,16    // 增加栈指针 sp 的值 16 字节，恢复栈指针
   c:	8082       ret
```
```s
000000000000000e <f>:

int f(int x) {
   e:	1141       addi	sp,sp,-16   // 减少栈指针 sp 的值 16 字节，为局部变量腾出空间
  10:	e422       sd	s0,8(sp)    // 将寄存器 s0 的值存储到栈指针 sp 的偏移 8 位置
  12:	0800       addi	s0,sp,16    // 将栈指针 sp 的值加 16，并存储到寄存器 s0 中
  return g(x);
}
  14:	250d       addiw a0,a0,3    // 调用 g(x) 实际上是计算 x + 3，并将结果存储到 a0 寄存器中
  16:	6422       ld s0,8(sp)      // 从栈指针 sp 的偏移 8 位置加载值到寄存器 s0 中
  18:	0141       addi	sp,sp,16    // 增加栈指针 sp 的值 16 字节，恢复栈指针
  1a:	8082       ret
```
```s
000000000000001c <main>:

void main(void) {
  1c:	1141       addi	sp,sp,-16   // 减少栈指针 sp 的值 16 字节，为局部变量腾出空间
  1e:	e406       sd	ra,8(sp)    // 将返回地址寄存器 ra 的值存储到栈指针 sp 的偏移 8 位置
  20:	e022       sd	s0,0(sp)    // 将寄存器 s0 的值存储到栈指针 sp 的偏移 0 位置
  22:	0800       addi	s0,sp,16    // 将栈指针 sp 的值加 16，并存储到寄存器 s0 中
  printf("%d %d\n", f(8)+1, 13);
  24:	4635        li	a2,13       // 将立即数 13 加载到寄存器 a2 中
  26:	45b1        li	a1,12       // 将立即数 12 加载到寄存器 a1 中
  28:	00000517    uipc a0,0x0     // 将 0 加载到寄存器 a0 中
  2c:	7b050513    addi a0,a0,1968 # 7d8 <malloc+0xea> // 将立即数 1968 加到寄存器 a0 中，并存储结果
  30:	00000097    auipc ra,0x0    // 将 0 加载到寄存器 ra 中
  34:	600080e7    jalr 1536(ra) # 630 <printf>// 无条件跳转到地址 1536(ra) # 630 <printf>
  exit(0);
  38:	4501        li	a0,0        // 将立即数 0 加载到寄存器 a0 中
  3a:	00000097    auipc ra,0x0    // 将 0 加载到寄存器 ra 中
  3e:	27e080e7    jalr 638(ra) # 2b8 <exit>// 无条件跳转到地址 638(ra) # 2b8 <exit>
```
### 问题一：
+ Q: 哪些寄存器存储了函数调用的参数？举个例子，main 调用 printf 的时候，13 被存在了哪个寄存器中？
+ A: 寄存器a0,a1,a2包含函数参数，调用printf时寄存器a2保存13
### 问题二：
+ Q: main 中调用函数 f 对应的汇编代码在哪？对 g 的调用呢？ (提示：编译器有可能会内链(inline)一些函数)
+ A: 没有这样的代码。 g(x) 被内链到 f(x) 中，然后 f(x) 又被进一步内链到 main() 中
### 问题三：
+ Q: printf 函数所在的地址是？
+ A: 0x0000000000000628, main 中使用 pc 相对寻址来计算得到这个地址。
### 问题四：
+ Q: 在 main 中 jalr 跳转到 printf 之后，ra 的值是什么？
+ A: 0x0000000000000038, jalr 指令的下一条汇编指令的地址。
### 问题五：
A: "He110 World"; 0x726c6400; 不需要，57616 的十六进制是 110，无论端序（十六进制和内存中的表示不是同个概念）
### 问题六：
A: 输出的是一个受调用前的代码影响的“随机”的值。因为 printf 尝试读的参数数量比提供的参数数量多。
第二个参数 ‘3’ 通过 a1 传递，而第三个参数对应的寄存器 a2 在调用前不会被设置为任何具体的值，而是会
包含调用发生前的任何已经在里面的值。








