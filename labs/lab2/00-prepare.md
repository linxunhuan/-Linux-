+ 题目网址：https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html
+ 官方提示：
+ 在开始编码之前,请阅读xv6 书的第 2 章、第 4 章的第 4.3 和 4.4 节以及相关源文件：
  + 系统调用的用户空间代码位于user/user.h和user/usys.pl中
  + 内核空间代码是kernel/syscall.h,kernel/syscall.c
  + 与进程相关的代码是kernel/proc.h和kernel/proc.c

------
# xv6

## 内核源文件

|文件|说明|
|:---:|:---:|
|bio.c|文件系统的磁盘块高速缓存|
|console.c|连接到用户的键盘和屏幕|
|entry.S|第一次启动指令|
|exec.s|系统调用|
|fs.c|文件系统|
|kalloc.c|物理页面分配器|
|kernelvec.S|处理来自内核的陷进,以及计时器中断|
|log.c|文件处理日志记录和崩溃恢复|
|main.c|控制引导过程中其他模块的初始化|
|pipe.c|管道|
|main.c|控制引导过程中其他模块的初始化|
|pipe.c|管道|
|plic.c|RISC-V中断控制器|
|printf.c|格式化输出到控制台|
|proc.c|进度和调到|
|sleeplock.c|占据cpu的锁|
|spinlock.c|不占据cpu的锁|
|start.c|早期机器模式启动代码|
|string.c|c的字符串|
|swtch.c|线程切换|
|syscall.c|映射：调度系统调用 -> 处理功能|
|sysfile.c|与文件相关的系统调用|
|sysproc.c|与进程相关的系统调用|
|trampoline.S|在用户和内核之间切换的汇编代码|
|trap.c|处理陷阱和中断的返回|
|uart.c|串口控制台设备驱动程序|
|virtio_disk.c|磁盘设备驱动程序|
|vm.c|管理页表和地址空间|






------
# 第二章操作系统组织
+ 操作系统必须满足三大需求：
  + 多任务
  + 隔离
  + 交互

## 抽象物理资源


## 进程概念
+ xv6的隔离单元是进程
  + 引入进程这个概念的作用：
    + 阻止了进程破坏或者监听另一个进程的内存、CPU、文件描述符等资源
    + 阻止了进程破坏内核本身,这样进程就无法破坏内核的隔离机制
  + 引入进程的注意点：
    + 问题应用或恶意应用可能会欺骗内核或者硬件,做一些坏事(例如规避隔离)
  + 内核用来实现进程的机制：
    + 用户/管理者模式标志
    + 地址空间
    + 线程时间切片
+ v6使用页表(硬件实现)来为每个进程提供自己的地址空间:
  + 目的：
    + 加强隔离,欺骗程序,让它觉得拥有属于自己的私有机器
  + 实现方式：
    + RISC-V页表将虚拟地址(RISC-V指令操作的地址)翻译(或映射)成物理地址(CPU芯片向主内存发送的地址)
-------
+ xv6为每一个进程维护了一张单独的页表,这张页表定义了进程的地址空间。如下图所示：
<img src=".\picture\image1.png">

+ 地址空间包括进程从虚拟地址0开始的的用户内存
+ 内存以上往下的顺序是：
  + 指令
  + 全局变量
  + 栈
  + 进程可以按需求扩展的“堆”空间(用于malloc)
+ 很多因素限制了进程地址空间的最大尺寸：
  + RISC-V上的指针是64位
  + 硬件仅使用低39位来从页表中查找虚拟地址,xv6只使用了39位中的38位
+ 因此,最大地址为2^38 - 1 = 0x3fffffffff,即MAXVA
+ 在地址空间顶部xv6保留了两页
  + 一页用于跳板页
  + 一页用于保存切换到内核的trapframe
----
+ 每个进程都有一个执行线程(简称线程),执行进程的指令
+ 线程可以被挂起,后面进行恢复
+ 为了透明地在进程间进行切换,内核暂停掉正在执行的线程,恢复其他进程的线程
+ 线程中的大部分状态(局部变量、函数调用返回地址)存放在线程栈中
+ 每个进程有两个栈：
  + 用户栈
  + 内核栈(p->kstack)

|内核|用户栈|内存栈|
|--------|:-------:|:--------:|
|执行用户指令|使用|空的|
|进程进入到内核时|仍然保持数据,但并未被使用|使用中|

## 内核是怎样启动
+ 当RISC-V计算机上电时,它将初始化自己,然后运行存储在只读内存上的boot loader
  + boot loader将xv6内核加载到内存中
+ CPU在机器模式下,从_entry执行xv6
+ RISC-V启动时,分页硬件还未启动：虚拟地址直接映射到物理地址上
+ loader将xv6内核加载到物理地址0x80000000的内存上
  + 之所以将内核放置在0x80000000而不是0x0,是因为从0x0到0x80000000这段地址包含了I/O设备
+ _entry中的指令创建了一个栈以便xv6运行C代码
  + xv6在start.c中声明了初始栈即stack0的空间
  + _entry中的代码将地址stack0+4096放在栈指针寄存器sp中,这个地址是栈的顶部,因为xv6中的栈向下生长
  + 现在内核有了一个栈,_entry执行了start中的C代码(kernel/start.c:21)
+ start函数执行了一些只允许在机器模式下进行的配置,然后切换到管理者模式
  + 为了进入管理者模式,RISC-V提供了mret指令
    + 这个指令通常用来从之前的管理者模式到机器模式的调用中返回
  + start并非从这样的调用中返回,而是做一些设置,假装之前有一个调用：
    + 它在mstatus寄存器中将之前的特权模式设置为管理者;
    + 在mepc寄存器中写入main的地址,从而将返回地址设置为main;
    + 在satp寄存器中写入0,来关闭管理者模式下虚拟地址转换,并且将所有中断和异常委派给管理者模式
+ 在跳转到管理者模式之前,start还执行了另外一个任务:
  + 它编程了时钟芯片来产生计时器中断
  + 等所有这些家务事都完成后,start调用mret来“返回”到管理者模式
    + 这使得程序计数器变更为main(kernel/main.c:11)
+ 在main (kernel/main.c:11)初始化完一些设备和子系统之后,它调用userinit (kernel/proc.c:212),创建了第一个进程
  + 第一个进程执行了一小段用RISC-V汇编语言编写的程序,initcode.S(user/initcode.S:1),通过调用exec系统调用回到内核
  + exec使用一段新程序(在这里是/init)替换当前进程的内存和寄存器
  + 当内核执行完exec,它返回到用户空间,/init进程中
  + 如果需要,Init(user/init.c:15)创建一个新的控制台设备文件,然后将其打开为文件描述符0,1和2,接着在控制台启动一个shell
+ 系统到这里就启动了

# 用户调用如何进入内核中的 exec 系统调用实现
+ 用户代码将exec的参数放在a0和a1中,将系统调用号放在a7中
+ 系统调用号与systemcalls数组中的项匹配
  + systemcalls是一个函数指针表(kernel/syscall.c:108)
+ ecall指令陷入内核,然后执行uservec,usertrap,然后是syscal
  + syscall(kernel/syscall.c:133)从trapframe所保存的a7中找到系统调用号,用它索引对应的系统调用
+ 对第一个系统调用来说,a7包含了SYS_exec(kernel/syscall.h:8),转到对系统调用实现函数sys_exec的调用
+ 当系统调用实现函数返回时,syscall将它的返回值记录在p->trapframe->a0中
  + 这将使得最初用户空间调用的exec()函数返回这个值
    + 负值表示错误,0或正数表示成功
    + 如果系统调用号是无效的,syscall打印错误并返回-1

# 代码：系统调用参数

+ 内核中的系统调用实现需要找到用户代码传来的参数
  + 因为用户代码调用的是系统调用包装程序,参数最初位于寄存器中
    + RISC-V C调用,通常放置参数在这
  + 内核trap代码将用户寄存器保存到当前进程的trapframe中,这样内核代码就能找到它们
  + 函数argint,argaddr和argfd从trapframe中找回第n个系统调用参数,作为整数,指针或是文件描述符
  + 它们都调用argraw来找回保存的对应用户寄存器(kernel/syscall.c:35)
+ 有些系统调用传递指针作为参数,然后内核必须使用这些指针读写用户内存
  + 举例来说,exec系统调用将一个指向用户空间字符串参数的指针数组传给内核,这些指针带来了两个挑战：
    + 用户程序可能有bug或是恶意的、
      + 可能传给内核无效的指针,也可能欺骗内核,使用这个指针访问内核内存而不是用户内存
    + xv6内核页表映射与用户页表不同
      + 内核不能使用普通指令来从用户提供的地址加载或存储内容。
+ 内核实现了能够安全地从/向用户提供的地址拷贝数据的函数
  + fetchstr是一个例子(kernel/syscall.c:25)
  + exec之类的文件系统调用使用fetchstr来从用户空间取回字符串类型的文件名参数
  + fetchstr调用copyinstr来完成困难的工作

+ copyinstr(kernel/vm.c:406)从虚拟地址srcva向dst拷贝最多max字节的数据
  + srcva是来自用户页表的虚拟地址
  + 它使用walkaddr(会调用walk)在软件中查找页表,确定srcva对应了物理地址pa0
  + 因为内核将所有物理RAM地址映射在相同的内核虚拟地址上,copyinstr能够直接从pa0往dst拷贝字符串数据
+ walkaddr(kernel/vm.c:95)检查用户提供的虚拟地址,保证它是这个进程的用户地址空间的一部分,从而避免程序欺骗内核读取别处的内存
+ copyout与之相似,从内核向用户提供的地址拷贝数据



